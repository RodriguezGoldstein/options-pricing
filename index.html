<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Monte Carlo Option Pricing — Self‑Contained Demo (D3)</title>
  <style>
    :root{--gap:12px}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto; margin:20px; color:#111}
    .grid{display:grid; gap:var(--gap); grid-template-columns:repeat(auto-fit,minmax(300px,1fr))}
    .card{border:1px solid #ddd; border-radius:12px; padding:12px; box-shadow:0 1px 2px rgba(0,0,0,.05); background:#fff}
    .row{display:flex; gap:var(--gap); align-items:flex-start; flex-wrap:wrap}
    .row > div{ min-width:160px; margin-bottom:8px }
    @media (max-width:520px){ .row > div{ min-width:120px } input,select{ width:100% } }
    label{display:block; font-size:12px; color:#555; margin-bottom:4px}
    /* fixed width controls for consistent layout */
    input,select{ width:140px; padding:8px; border:1px solid #ccc; border-radius:8px; box-sizing:border-box }
    textarea{ width:100%; padding:8px; border:1px solid #ccc; border-radius:8px; box-sizing:border-box }
    #optType{ width:140px }
    button{padding:10px 14px; border:0; border-radius:10px; background:#111; color:#fff; cursor:pointer}
    button.secondary{background:#444}
    pre{white-space:pre-wrap}
    svg.chart{display:block; width:100%; height:340px; border-radius:10px; background:#fafafa; overflow:hidden; touch-action:none}
    textarea{resize:vertical; overflow:auto}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .legend{display:flex; flex-wrap:wrap; gap:8px; font-size:12px; color:#444; align-items:center}
    .sw{width:12px; height:12px; border-radius:3px; display:inline-block; margin-right:6px}
    .sw.blue{background:#4b9ce2}
    .sw.black{background:#111}
    .sw.red{background:#ef4444}
    .sw.gray{background:#777}
    .hint{font-size:12px; color:#666}
    .tooltip{position:fixed; pointer-events:none; background:rgba(0,0,0,.8); color:#fff; padding:6px 8px; border-radius:6px; font-size:12px; line-height:1.2; transform:translate(8px,8px); z-index:9999}
    .strategy-card{background:linear-gradient(90deg, #f8fbff, #ffffff); border-left:4px solid #4b9ce2; box-shadow:0 2px 6px rgba(75,156,226,0.08);}
    .strategy-card h4{margin:0 0 6px 0}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body>
  <h1>Monte Carlo Option Pricing</h1>
  <div class="grid">
    <div class="column">
      <div class="card">
      <div class="row">
        <div style="flex:1"><label for="optType">Type</label><select id="optType"><option>call</option><option>put</option></select></div>
        </div>
        <div class="row">
        <div style="flex:1"><label for="S0">S₀</label><input id="S0" type="number" value="100" step="1"></div>
        <div style="flex:1"><label for="K">K</label><input id="K" type="number" value="100" step="1"></div>
        <div style="flex:1"><label for="marketPrice">Market Price</label><input id="marketPrice" type="number" placeholder="(optional)" step="0.01"></div>
        </div>
      <div class="row">
        <div style="flex:1"><label for="r">r</label><input id="r" type="number" value="0.03" step="0.001"></div>
        <div style="flex:1"><label for="sigma">σ</label><input id="sigma" type="number" value="0.25" step="0.01"></div>
        <div style="flex:1"><label for="T">T (yrs)</label><input id="T" type="number" value="0.5" step="0.05"></div>
      </div>
      <div class="row" style="margin-top:var(--gap)">
        <div style="flex:1"><label for="steps">steps</label><input id="steps" type="number" value="128" step="1"></div>
        <div style="flex:1"><label for="paths">paths</label><input id="paths" type="number" value="80000" step="1000"></div>
        <div style="flex:1"><label for="seed">seed</label><input id="seed" type="number" value="12345" step="1"></div>
        <div style="flex:1"><label for="cv">control variate</label><select id="cv"><option value="1" selected>on</option><option value="0">off</option></select></div>
        <div style="flex:1"><label for="bsRisk">BS model‑risk CI (%)</label><input id="bsRisk" type="number" value="5" step="0.5"></div>
        <div style="flex:1">  </div>
      </div>
      <div class="row" style="margin-top:6px">
        <div style="flex:1"><label for="strategySource">Strategy Source</label><select id="strategySource"><option value="auto" selected>auto (market if provided)</option><option value="market">market</option><option value="bs">Black–Scholes</option></select></div>
        <div style="flex:1"><label for="decisionZ">Decision Z‑threshold</label><input id="decisionZ" type="number" value="1.645" step="0.01"></div>
        <div style="flex:1"></div>
      </div>
      <div class="row" style="margin-top:var(--gap)">
        <div style="flex:1">
          <label for="antithetic">antithetic variates</label>
          <select id="antithetic"><option value="1" selected>on</option><option value="0">off</option></select>
        </div>
        <div style="flex:1">
          <label for="pathsLog">paths: log‑scale</label>
          <select id="pathsLog"><option value="0" selected>off</option><option value="1">on</option></select>
        </div>
        <div style="flex:1">
          <label for="payoffLog">payoff diagram: log S axis</label>
          <select id="payoffLog"><option value="0" selected>off</option><option value="1">on</option></select>
        </div>
      </div>
      <br>
      <div style="flex:1">
        <button id="runBtn">Run Simulation</button>
      </div>
    </div>
    <br>
        <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Diagnostics</strong>
        <!--<button id="runDiag" class="secondary">Run Diagnostics</button>-->
      </div>
      <textarea id="diag" class="mono" rows="12">(run diagnostics)</textarea>
    </div>
  </div>
<div class="column">  
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Strategy</strong>
      </div>
      <div id="strategy" class="mono" style="white-space:pre-wrap; margin-top:8px; color:#111">(run simulation to see strategy recommendation)</div>
    </div>
</div>
  <div class="column">
        <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Simulated Price Paths</strong>
      </div>
      <svg id="pathsChart" class="chart"></svg>
    </div>
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Discounted Payoff Distribution</strong>
      </div>
      <svg id="hist" class="chart"></svg>
    </div>
  </div>
  <div class="column">
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Estimator Comparison</strong>
      </div>
      <svg id="bars" class="chart"></svg>
    </div>
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Payoff at Expiration</strong>
      </div>
      <svg id="payoffDiagram" class="chart"></svg>
    </div>
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Profit Distribution (exec price)</strong>
      </div>
      <svg id="profitHist" class="chart"></svg>
    </div>
  </div>
  </div>
  <script>
  // All JS runs after DOMContentLoaded to avoid missing elements.
  document.addEventListener('DOMContentLoaded', function(){
    const $ = (id) => document.getElementById(id) || null;
    const bind = (id, evt, handler) => { const el=$(id); if(!el||!el.addEventListener){ console.error(`[fatal] bind ${evt} #${id}`); return false;} el.addEventListener(evt,handler,{passive:false}); console.log(`[bind] ${evt} #${id}`); return true; };
    // tooltip (shared)

    // persist marketPrice in localStorage
    function persistMarketPriceInit(){ try{ const me = document.getElementById('marketPrice'); if(me){ try{ const v = localStorage.getItem('marketPrice'); if(v!==null) me.value = v; }catch(e){} me.addEventListener('change', ()=>{ try{ if(me.value==='') localStorage.removeItem('marketPrice'); else localStorage.setItem('marketPrice', me.value); }catch(e){} }); } }catch(e){} }

    function createTooltip(){
      let div=d3.select('body').append('div').attr('class','tooltip').style('opacity',0);
      function show(html, evt){ div.html(html).style('opacity',1).style('left', (evt.clientX+10)+'px').style('top',(evt.clientY+10)+'px'); }
      function hide(){ div.style('opacity',0); }
      return {div, show, hide};
    }
    const tooltip = createTooltip();
    try{ persistMarketPriceInit(); }catch(e){}
    // --------- readers (defensive) ---------
    const readSelect = (id, fallback) => { const el=$(id); const v=el && el.value; return (v===undefined||v===null||v==='')? fallback : v; };
    const readNum = (id, fallback) => { const el=$(id); const v = el? parseFloat(el.value) : NaN; return Number.isFinite(v)? v : fallback; };
    const readInt = (id, fallback) => { const el=$(id); const v = el? parseInt(el.value,10) : NaN; return Number.isFinite(v)? v : fallback; };
    // ---------- Maths & Finance ----------
    const C=Math; const isFiniteNumber = x => typeof x==='number' && Number.isFinite(x);
    function cdfN(x){ const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const s=x<0?-1:1, ax=C.abs(x)/C.sqrt(2), t=1/(1+p*ax); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*C.exp(-ax*ax); return 0.5*(1+s*y);} 
    const pdfN = x => (1/C.sqrt(2*C.PI))*C.exp(-0.5*x*x);
    function BS(S,K,r,sig,T,type){ const d1=(C.log(S/K)+(r+0.5*sig*sig)*T)/(sig*C.sqrt(T)); const d2=d1-sig*C.sqrt(T); return type==='call'? S*cdfN(d1)-K*C.exp(-r*T)*cdfN(d2) : K*C.exp(-r*T)*cdfN(-d2)-S*cdfN(-d1); }
    function BSGreeks(S,K,r,sig,T,type){ const d1=(C.log(S/K)+(r+0.5*sig*sig)*T)/(sig*C.sqrt(T)); const d2=d1-sig*C.sqrt(T); const Nd1=cdfN(d1), Nd2=cdfN(d2), nd1=pdfN(d1); let delta,theta,rho; if(type==='call'){ delta=Nd1; theta=-(S*nd1*sig)/(2*C.sqrt(T))-r*K*C.exp(-r*T)*Nd2; rho=K*T*C.exp(-r*T)*Nd2;} else { delta=Nd1-1; theta=-(S*nd1*sig)/(2*C.sqrt(T))+r*K*C.exp(-r*T)*cdfN(-d2); rho=-K*T*C.exp(-r*T)*cdfN(-d2);} const gamma=nd1/(S*sig*C.sqrt(T)); const vega=S*nd1*C.sqrt(T); return {Delta:delta, Gamma:gamma, Vega:vega, 'Theta (per year)':theta, Rho:rho}; }
    function makeLCG(seed){ let s=(seed>>>0)||1; return ()=>((s=(1664525*s+1013904223)>>>0),(s>>>0)/0x100000000); }
    function normalBM(rng){ let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng(); return C.sqrt(-2*C.log(u))*C.cos(2*C.PI*v); }
    function sanitize(p){ return { type:p.type==='put'?'put':'call', S0:isFiniteNumber(p.S0)?p.S0:100, K:isFiniteNumber(p.K)?p.K:100, r:isFiniteNumber(p.r)?p.r:0.03, sigma:C.max(0,isFiniteNumber(p.sigma)?p.sigma:0.2), T:C.max(1e-8,isFiniteNumber(p.T)?p.T:0.5), steps:C.max(1,(p.steps|0)||64), paths:C.max(10,(p.paths|0)||20000), seed:C.max(1,(p.seed|0)||1) }; }
    function simulateMC(params,useAntithetic){ const p=sanitize(params); const dt=p.T/p.steps, disc=C.exp(-p.r*p.T), rng=makeLCG(p.seed); const N=useAntithetic?(p.paths+(p.paths%2)):p.paths; const pay=new Float64Array(N), dST=new Float64Array(N), ST=new Float64Array(N), Zbar=new Float64Array(N); const sdt=C.sqrt(dt), drift=(p.r-0.5*p.sigma*p.sigma)*dt, vol=p.sigma*sdt; for(let i=0;i<N;){ let S1=p.S0, zsum1=0; const zs=[]; for(let t=0;t<p.steps;t++){ const z=normalBM(rng); zs.push(z); zsum1+=z; S1*=C.exp(drift+vol*z);} let S2=p.S0, zsum2=0; for(let t=0;t<p.steps;t++){ const z=-zs[t]; zsum2+=z; S2*=C.exp(drift+vol*z);} const po1=p.type==='call'?C.max(S1-p.K,0):C.max(p.K-S1,0); const po2=p.type==='call'?C.max(S2-p.K,0):C.max(p.K-S2,0); pay[i]=disc*po1; dST[i]=disc*S1; ST[i]=S1; Zbar[i]=zsum1/C.sqrt(p.steps); i++; if(i<N){ pay[i]=disc*po2; dST[i]=disc*S2; ST[i]=S2; Zbar[i]=zsum2/C.sqrt(p.steps); i++; } } const n=p.paths; const payS=pay.slice(0,n), dSTS=dST.slice(0,n), STS=ST.slice(0,n), ZS=Zbar.slice(0,n); let sum=0; for(let i=0;i<n;i++) sum+=payS[i]; const mean=sum/n; let vs=0; for(let i=0;i<n;i++){ const d=payS[i]-mean; vs+=d*d;} const se=C.sqrt(vs/C.max(1,n-1))/C.sqrt(n), ciLow=mean-1.96*se, ciHigh=mean+1.96*se; return [mean,se,ciLow,ciHigh, payS,dSTS,STS,ZS,p]; }
    // ---------- Web Worker (Blob) for simulateMC ----------
    // create a Blob-based worker that runs simulateMC off the main thread
    let mcWorker = null;
    let workerAvailable = false;
    try{
      const workerCode = [
        "function makeLCG(seed){ let s=(seed>>>0)||1; return function(){ s=(1664525*s+1013904223)>>>0; return (s>>>0)/0x100000000; }; }",
        "function normalBM(rng){ var u=0,v=0; while(u===0) u=rng(); while(v===0) v=rng(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }",
        "function sanitize(p){ return { type:p.type==='put'?'put':'call', S0:(typeof p.S0==='number'&&isFinite(p.S0))?p.S0:100, K:(typeof p.K==='number'&&isFinite(p.K))?p.K:100, r:(typeof p.r==='number'&&isFinite(p.r))?p.r:0.03, sigma:Math.max(0,(typeof p.sigma==='number'&&isFinite(p.sigma))?p.sigma:0.2), T:Math.max(1e-8,(typeof p.T==='number'&&isFinite(p.T))?p.T:0.5), steps:Math.max(1, (p.steps|0)||64), paths:Math.max(10,(p.paths|0)||20000), seed:Math.max(1,(p.seed|0)||1) }; }",
        "function simulateMC(params,useAntithetic){ var p=sanitize(params); var dt=p.T/p.steps, disc=Math.exp(-p.r*p.T), rng=makeLCG(p.seed); var N=useAntithetic?(p.paths+(p.paths%2)):p.paths; var pay=new Float64Array(N), dST=new Float64Array(N), ST=new Float64Array(N), Zbar=new Float64Array(N); var sdt=Math.sqrt(dt), drift=(p.r-0.5*p.sigma*p.sigma)*dt, vol=p.sigma*sdt; for(var i=0;i<N;){ var S1=p.S0, zsum1=0, zs=[]; for(var t=0;t<p.steps;t++){ var z=normalBM(rng); zs.push(z); zsum1+=z; S1*=Math.exp(drift+vol*z);} var S2=p.S0, zsum2=0; for(var t=0;t<p.steps;t++){ var z=-zs[t]; zsum2+=z; S2*=Math.exp(drift+vol*z);} var po1=p.type==='call'?Math.max(S1-p.K,0):Math.max(p.K-S1,0); var po2=p.type==='call'?Math.max(S2-p.K,0):Math.max(p.K-S2,0); pay[i]=disc*po1; dST[i]=disc*S1; ST[i]=S1; Zbar[i]=zsum1/Math.sqrt(p.steps); i++; if(i<N){ pay[i]=disc*po2; dST[i]=disc*S2; ST[i]=S2; Zbar[i]=zsum2/Math.sqrt(p.steps); i++; } } var n=p.paths; var payS=pay.slice(0,n), dSTS=dST.slice(0,n), STS=ST.slice(0,n), ZS=Zbar.slice(0,n); var sum=0; for(var i=0;i<n;i++) sum+=payS[i]; var mean=sum/n; var vs=0; for(var i=0;i<n;i++){ var d=payS[i]-mean; vs+=d*d;} var se=Math.sqrt(vs/Math.max(1,n-1))/Math.sqrt(n), ciLow=mean-1.96*se, ciHigh=mean+1.96*se; return { mean:mean, se:se, ciLow:ciLow, ciHigh:ciHigh, payS:payS, dSTS:dSTS, STS:STS, ZS:ZS, p:p }; }",
        "self.onmessage = function(e){ var data=e.data; if(!data||data.cmd!=='simulate') return; var id=data.id, params=data.params, useAnt=data.useAntithetic; try{ var res = simulateMC(params, useAnt); var transfer=[]; if(res.payS && res.payS.buffer) transfer.push(res.payS.buffer); if(res.dSTS && res.dSTS.buffer) transfer.push(res.dSTS.buffer); if(res.STS && res.STS.buffer) transfer.push(res.STS.buffer); if(res.ZS && res.ZS.buffer) transfer.push(res.ZS.buffer); self.postMessage({id:id, ok:true, result:res}, transfer); } catch(err){ self.postMessage({id:id, ok:false, error:(err&&err.message)?err.message:String(err)}); } };"
      ].join('\n');
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      mcWorker = new Worker(URL.createObjectURL(blob));
      workerAvailable = true;
      mcWorker.addEventListener('error', function(e){ console.warn('[worker] error', e); workerAvailable = false; mcWorker.terminate(); mcWorker = null; });
    }catch(e){ console.warn('worker create failed', e); workerAvailable = false; mcWorker = null; }
    function simulateMCAsync(params,useAntithetic){
      if(workerAvailable && mcWorker){
        return new Promise((resolve,reject)=>{
          const id = Math.random().toString(36).slice(2);
          function onmsg(evt){ const d=evt.data; if(!d||d.id!==id) return; mcWorker.removeEventListener('message', onmsg); if(d.ok){ const r=d.result; // rewrap transferred buffers
              try{ r.payS = r.payS && !(r.payS instanceof Float64Array) ? new Float64Array(r.payS) : r.payS; r.dSTS = r.dSTS && !(r.dSTS instanceof Float64Array) ? new Float64Array(r.dSTS) : r.dSTS; r.STS = r.STS && !(r.STS instanceof Float64Array) ? new Float64Array(r.STS) : r.STS; r.ZS = r.ZS && !(r.ZS instanceof Float64Array) ? new Float64Array(r.ZS) : r.ZS; resolve([r.mean, r.se, r.ciLow, r.ciHigh, r.payS, r.dSTS, r.STS, r.ZS, r.p]); }catch(err){ reject(err); } } else { reject(new Error(d.error || 'worker error')); } }
          mcWorker.addEventListener('message', onmsg);
          mcWorker.postMessage({ id:id, cmd:'simulate', params:params, useAntithetic: !!useAntithetic });
        });
      }
      // fallback to main-thread simulateMC
      return Promise.resolve(simulateMC(params,useAntithetic));
    }
    function controlVariate(pay,discST,target){ const n=pay.length; const x=new Float64Array(n); let mx=0,my=0; for(let i=0;i<n;i++){ x[i]=discST[i]-target; mx+=x[i]; my+=pay[i]; } mx/=n; my/=n; let vx=0,cov=0; for(let i=0;i<n;i++){ const dx=x[i]-mx, dy=pay[i]-my; vx+=dx*dx; cov+=dx*dy;} vx/=Math.max(1,n-1); cov/=Math.max(1,n-1); const adj=new Float64Array(n); if(vx<=0){ adj.set(pay);} else { const beta=cov/vx; for(let i=0;i<n;i++) adj[i]=pay[i]-beta*x[i]; } let s=0; for(let i=0;i<n;i++) s+=adj[i]; const mean=s/n; let vs=0; for(let i=0;i<n;i++){ const d=adj[i]-mean; vs+=d*d;} const se=Math.sqrt(vs/Math.max(1,n-1))/Math.sqrt(n), ciLow=mean-1.96*se, ciHigh=mean+1.96*se; return {mean,se,ciLow,ciHigh,samples:adj}; }
    function mcPathGreeks(p,ST,Zbar){ const disc=Math.exp(-p.r*p.T), n=ST.length, sqrtT=Math.sqrt(p.T); const indC=new Float64Array(n), indP=new Float64Array(n); for(let i=0;i<n;i++){ indC[i]=ST[i]>p.K?1:0; indP[i]=ST[i]<p.K?1:0; } const gC=indC, gP=new Float64Array(n); for(let i=0;i<n;i++) gP[i]=-indP[i]; const dS0=new Float64Array(n), dSig=new Float64Array(n), dR=new Float64Array(n); for(let i=0;i<n;i++){ dS0[i]=ST[i]/p.S0; dSig[i]=ST[i]*(-p.sigma*p.T+sqrtT*Zbar[i]); dR[i]=p.T*ST[i]; } const pC=i=>Math.max(ST[i]-p.K,0), pP=i=>Math.max(p.K-ST[i],0); const dlt=new Float64Array(n), veg=new Float64Array(n), rho=new Float64Array(n); if(p.type==='call'){ for(let i=0;i<n;i++){ dlt[i]=disc*gC[i]*dS0[i]; veg[i]=disc*gC[i]*dSig[i]; rho[i]=disc*(-p.T*pC(i)+gC[i]*dR[i]); } } else { for(let i=0;i<n;i++){ dlt[i]=disc*gP[i]*dS0[i]; veg[i]=disc*gP[i]*dSig[i]; rho[i]=disc*(-p.T*pP(i)+gP[i]*dR[i]); } } function mSe(a){ const n=a.length; let s=0; for(let i=0;i<n;i++) s+=a[i]; const m=s/n; let vs=0; for(let i=0;i<n;i++){ const d=a[i]-m; vs+=d*d;} return {mean:m,se:Math.sqrt(vs/Math.max(1,n-1))/Math.sqrt(n)}; } const D=mSe(dlt), V=mSe(veg), R=mSe(rho); return {delta:D.mean, vega:V.mean, rho:R.mean, seDelta:D.se, seVega:V.se, seRho:R.se}; }
    // ---------- D3 helpers ----------
    let clipIdCounter = 0;
    function getSize(svg){ const r=svg.node().getBoundingClientRect(); return {w:r.width, h:r.height}; }
    // setupSVG now returns a top-level group `g` (for axes) and a clipped `plot` group for plotted shapes
    function setupSVG(svg){ svg.selectAll('*').remove(); const {w,h}=getSize(svg); const m={t:20,r:40,b:40,l:50}; const g=svg.append('g').attr('transform',`translate(${m.l},${m.t})`); let iw=w-m.l-m.r, ih=h-m.t-m.b;
      // guard against zero/NaN sizes (can happen if element not yet laid out)
      if(!Number.isFinite(iw) || iw <= 0) iw = Math.max(1, (svg.node().clientWidth || 600) - m.l - m.r);
      if(!Number.isFinite(ih) || ih <= 0) ih = Math.max(1, (svg.node().clientHeight || 340) - m.t - m.b);
      const clipId = `mc-clip-${++clipIdCounter}`;
      svg.append('defs').append('clipPath').attr('id',clipId).append('rect').attr('x',0).attr('y',0).attr('width',iw).attr('height',ih);
      const plot = g.append('g').attr('class','plot').attr('clip-path',`url(#${clipId})`);
      return {g, plot, iw, ih, m, w, h}; }
    function fmt(v,n=4){ return Number.isFinite(v)? v.toFixed(n): String(v); }
    // Histogram (D3) with tooltip
    function drawHistogramD3(svgSel, centers, counts){
      const svg=d3.select(svgSel); const {g, plot, iw, ih}=setupSVG(svg);
      const x=d3.scaleLinear().domain(d3.extent(centers)).range([0,iw]);
      const y=d3.scaleLinear().domain([0, d3.max(counts)||1]).nice().range([ih,0]);
      const xAxis=g.append('g').attr('transform',`translate(0,${ih})`).call(d3.axisBottom(x).ticks(6));
      const yAxis=g.append('g').call(d3.axisLeft(y).ticks(5));
      const bw = iw/Math.max(centers.length,1);
      // pair centers/counts and filter non-finite entries
      const histData = centers.map((c,i)=>({c, n:counts[i]})).filter(d=>Number.isFinite(d.c) && Number.isFinite(d.n));
      if(histData.length===0) return; // nothing valid to draw
      // draw bars into the clipped plot group so axes remain visible
      plot.selectAll('rect.bar').data(histData).join('rect')
        .attr('class','bar')
        .attr('x',d=>Number.isFinite(x(d.c))? x(d.c)-bw/2 : 0)
        .attr('width', Math.max(1, bw*0.95))
        .attr('y',d=>{ const yy = y(d.n); return Number.isFinite(yy)? yy : ih; })
        .attr('height',d=>{ const yy = y(d.n); return Number.isFinite(yy)? (ih - yy) : 0; })
        .attr('fill','#4b9ce2')
        .on('mousemove', (evt,d)=> tooltip.show(`<b>center</b> ${fmt(d.c)}<br><b>count</b> ${d.n}`, evt))
        .on('mouseleave', ()=> tooltip.hide());
      console.log('[drawPayoffD3] drawn dots', plot.selectAll('rect.dot').size());
      const zoom=d3.zoom().scaleExtent([0.5, 20]).on('zoom', (e)=>{
        const zx=e.transform.rescaleX(x); xAxis.call(d3.axisBottom(zx).ticks(6));
        plot.selectAll('rect.bar')
          .attr('x',d=>Number.isFinite(zx(d.c))? zx(d.c)-bw/2 : 0)
          .attr('width', Math.max(1, (zx(centers[1]||centers[0]) - zx(centers[0]))*0.95 ));
      });
      svg.call(zoom).on('dblclick.zoom', null);
      svg.on('dblclick', ()=>{ svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity); });
    }
    // Bars (estimators) with shaded 95% CI (MC) + BS model‑risk band and tooltip
    function drawBarsD3(svgSel, labels, values, ciLows=[], ciHighs=[]){
      const svg=d3.select(svgSel); const {g, plot, iw, ih}=setupSVG(svg);
      // filter finite values
      const vals = values.map(v=> Number.isFinite(v)? v : NaN);
      const x=d3.scaleLinear().domain([0, labels.length]).range([0,iw]);
      const yMax = d3.max([d3.max(vals.filter(Number.isFinite)) || 1, d3.max(ciHighs.filter(Number.isFinite)) || 0]);
      const y=d3.scaleLinear().domain([0, yMax]).nice().range([ih,0]);
      const xAxis=g.append('g').attr('transform',`translate(0,${ih})`).call(d3.axisBottom(x).ticks(labels.length).tickFormat((i)=>labels[i]||''));
      const yAxis=g.append('g').call(d3.axisLeft(y).ticks(5));
      const bw = iw/Math.max(1, labels.length)*0.55;
      // CI bands (rectangles) behind bars
      const hasCI = (i)=> Number.isFinite(ciLows[i]) && Number.isFinite(ciHighs[i]) && ciHighs[i] >= ciLows[i];
      // CI bands drawn into clipped plot group
      const ciData = values.map((v,i)=>({i, lo:ciLows[i], hi:ciHighs[i]})).filter(d=> Number.isFinite(d.lo) && Number.isFinite(d.hi));
      plot.selectAll('rect.ci').data(ciData).join('rect')
        .attr('class','ci')
        .attr('x',d=>x(d.i+0.5)-bw/2)
        .attr('width',bw)
        .attr('y',d=> y(d.hi))
        .attr('height',d=> (y(d.lo)-y(d.hi)))
        .attr('fill','rgba(75,156,226,0.20)');
      // Bars
      const barData = values.map((v,i)=>({v,i})).filter(d=> Number.isFinite(d.v));
      const bars = plot.selectAll('rect.bar').data(barData).join('rect')
        .attr('class','bar')
        .attr('x',d=>x(d.i+0.5)-bw/2)
        .attr('y',d=>y(d.v))
        .attr('width',bw)
        .attr('height',d=>ih - y(d.v))
        .attr('fill','#111')
        .on('mousemove', (evt,d)=>{
          const ciTxt = hasCI(d.i)? `<br><b>CI</b> [${fmt(ciLows[d.i])}, ${fmt(ciHighs[d.i])}]` : '';
          tooltip.show(`<b>${labels[d.i]}</b><br><b>value</b> ${fmt(d.v)}${ciTxt}`, evt);
        })
        .on('mouseleave', ()=> tooltip.hide());
      const zoom=d3.zoom().scaleExtent([0.8, 10]).on('zoom', (e)=>{
        const zx=e.transform.rescaleX(x); xAxis.call(d3.axisBottom(zx).ticks(labels.length).tickFormat((v)=>labels[Math.round(v-0.5)]||''));
        plot.selectAll('rect.ci').attr('x',d=>Number.isFinite(zx(d.i+0.5))? zx(d.i+0.5)-bw/2 : 0);
        bars.attr('x',d=>Number.isFinite(zx(d.i+0.5))? zx(d.i+0.5)-bw/2 : 0);
      });
      svg.call(zoom).on('dblclick.zoom', null);
      svg.on('dblclick', ()=>{ svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity); });
    }
    // Price paths (subset)
    function drawPathsD3(svgSel, paths, logY){
      const svg=d3.select(svgSel); const {g, plot, iw, ih}=setupSVG(svg);
      if(!Array.isArray(paths) || paths.length===0) return;
      const nSteps = paths[0]?.length || 1;
      const x=d3.scaleLinear().domain([0, nSteps-1]).range([0,iw]);
      const values = paths.flat().filter(Number.isFinite);
      if(values.length===0) return;
      const yDomain = d3.extent(values.map(v => logY? Math.log(Math.max(1e-12,v)) : v));
      const y=d3.scaleLinear().domain(yDomain).nice().range([ih,0]);
      const xAxis=g.append('g').attr('transform',`translate(0,${ih})`).call(d3.axisBottom(x));
      const yAxis=g.append('g').call(d3.axisLeft(y));
      const line=d3.line().x((d,i)=>x(i)).y(d=>y(logY? Math.log(Math.max(1e-12,d)) : d));
      // draw paths into clipped plot group (filter invalid points per path)
      const safePaths = paths.map(p => Array.isArray(p)? p.filter(Number.isFinite) : []).filter(p=>p.length>0);
      if(safePaths.length===0) return;
      plot.selectAll('path.path').data(safePaths).join('path')
        .attr('class','path')
        .attr('fill','none').attr('stroke','rgba(75,156,226,0.6)').attr('stroke-width',1)
        .attr('d',d=>line(d));
      const overlay=plot.append('rect').attr('fill','transparent').attr('pointer-events','all').attr('x',0).attr('y',0).attr('width',iw).attr('height',ih)
        .on('mousemove',(evt)=>{
          const pt=d3.pointer(evt); const t=x.invert(pt[0]); tooltip.show(`<b>t</b> ${fmt(t,3)}`, evt);
        })
        .on('mouseleave', ()=> tooltip.hide());
      console.log('[drawPayoffD3] drawn dots', plot.selectAll('rect.dot').size());
      const zoom=d3.zoom().scaleExtent([0.5, 20]).on('zoom', (e)=>{
        const zx=e.transform.rescaleX(x); xAxis.call(d3.axisBottom(zx));
        plot.selectAll('path.path').attr('d', d3.line().x((d,i)=>zx(i)).y(d=>y(logY? Math.log(Math.max(1e-12,d)) : d)));
      });
      svg.call(zoom).on('dblclick.zoom', null);
      svg.on('dblclick', ()=>{ svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity); });
    }
    // Payoff diagram (scatter + payoff curve) with tooltip
    function drawPayoffD3(svgSel, K, type, ST, payoffs, logS){
      console.log('[drawPayoffD3] called for', svgSel);
      const svg=d3.select(svgSel); const {g, plot, iw, ih}=setupSVG(svg);
      console.log('[drawPayoffD3] svg size', {iw,ih});
      if(!ST || ST.length===0) return;
      if(!payoffs || payoffs.length===0) return;
      // Build paired (S_T, payoff) points by index so filtering doesn't desynchronize arrays
      const dots = [];
      for(let i=0;i<Math.min(ST.length, payoffs.length); i++){
        const s = ST[i]; const p = payoffs[i];
        if(!Number.isFinite(s) || !Number.isFinite(p)) continue;
        const sx = logS? Math.log(Math.max(1e-12, s)) : s;
        if(!Number.isFinite(sx)) continue;
        dots.push({ sx, py: p });
      }
      console.log('[drawPayoffD3] points', dots.length, 'K=',K, 'type=',type, 'logS=',logS);
      if(dots.length===0) return;
      // cap scatter to avoid drawing huge numbers of DOM nodes
      const scatterCap = 4000;
      if(dots.length>scatterCap){ const stride = Math.ceil(dots.length/scatterCap); const tmp=[]; for(let i=0;i<dots.length;i+=stride) tmp.push(dots[i]); dots.length=0; Array.prototype.push.apply(dots,tmp); }
      const xs = dots.map(d=>d.sx);
      const pvals = dots.map(d=>d.py);
      const x = d3.scaleLinear().domain(d3.extent(xs)).nice().range([0,iw]);
      const y = d3.scaleLinear().domain(d3.extent(pvals)).nice().range([ih,0]);
      const xAxis=g.append('g').attr('transform',`translate(0,${ih})`).call(d3.axisBottom(x));
      const yAxis=g.append('g').call(d3.axisLeft(y));
      // payoff curve
      const samples=200; const xdom=x.domain();
      const xGrid=d3.range(samples+1).map(i=>xdom[0] + (i/samples)*(xdom[1]-xdom[0]));
      const line=d3.line().x(d=>x(d)).y(d=>{ const s=logS? Math.exp(d) : d; const py = type==='call'? Math.max(s-K,0) : Math.max(K-s,0); return y(py); });
      plot.append('path').datum(xGrid).attr('fill','none').attr('stroke','#111').attr('stroke-width',1.5).attr('d',line);
      // scatter
      plot.selectAll('rect.dot').data(dots).join('rect')
        .attr('class','dot').attr('x',d=>x(d.sx)-1).attr('y',d=>y(d.py)-1).attr('width',2).attr('height',2)
        .attr('fill','rgba(239,68,68,0.55)')
        .on('mousemove',(evt,d)=> tooltip.show(`<b>S_T</b> ${fmt(logS? Math.exp(d.sx): d.sx)}<br><b>payoff</b> ${fmt(d.py)}`, evt))
        .on('mouseleave', ()=> tooltip.hide());
      console.log('[drawPayoffD3] drawn dots', plot.selectAll('rect.dot').size());
      const zoom=d3.zoom().scaleExtent([0.5, 20]).on('zoom', (e)=>{
        const zx=e.transform.rescaleX(x); const zy=e.transform.rescaleY(y);
        xAxis.call(d3.axisBottom(zx)); yAxis.call(d3.axisLeft(zy));
        const lineZ=d3.line().x(d=>zx(d)).y(d=>{ const s=logS? Math.exp(d) : d; const py= type==='call'? Math.max(s-K,0) : Math.max(K-s,0); return zy(py); });
        plot.selectAll('path').attr('d',lineZ(xGrid));
        plot.selectAll('rect.dot').attr('x',d=>zx(d.sx)-1).attr('y',d=>zy(d.py)-1);
      });
      svg.call(zoom).on('dblclick.zoom', null);
      svg.on('dblclick', ()=>{ svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity); });
    }
    // ---------- Orchestration ----------
    async function runSim(){
      console.log('[runSim] invoked');
      const p={ type: readSelect('optType','call'), S0: readNum('S0',100), K: readNum('K',100), r: readNum('r',0.03), sigma: readNum('sigma',0.25), T: readNum('T',0.5), steps: readInt('steps',128), paths: readInt('paths',80000), seed: readInt('seed',12345) };
      const marketPrice = readNum('marketPrice', NaN);
      const strategySource = readSelect('strategySource','auto');
      const decisionZ = readNum('decisionZ',1.645);
      const useCV = readSelect('cv','1')==='1';
      const useAntithetic = readSelect('antithetic','1')==='1';
      const pathsLog = readSelect('pathsLog','0')==='1';
      const payoffLog = readSelect('payoffLog','0')==='1';
      const bsRiskPct = readNum('bsRisk', 5.0)/100;
      // run simulation (worker if available)
      let mean,se,ciLow,ciHigh,payoffs,discST,ST,Zbar,sp;
      try{
        const res = await simulateMCAsync(p,useAntithetic);
        [mean,se,ciLow,ciHigh,payoffs,discST,ST,Zbar,sp] = res;
      }catch(err){ console.error('[simulateMCAsync] failed, falling back sync', err); const res = simulateMC(p,useAntithetic); [mean,se,ciLow,ciHigh,payoffs,discST,ST,Zbar,sp] = res; }
      // subset of paths for plotting (≤ 200)
      const rng=makeLCG(sp.seed); const dt=sp.T/sp.steps, sdt=Math.sqrt(dt), drift=(sp.r-0.5*sp.sigma*sp.sigma)*dt, vol=sp.sigma*sdt; const subsetCount=200; const stride=Math.max(1, Math.floor(sp.paths/subsetCount)); const paths=[]; for(let i=0;i<sp.paths;i+=stride){ let S=sp.S0; const path=[S]; for(let t=0;t<sp.steps;t++){ const z=normalBM(rng); S*=Math.exp(drift+vol*z); path.push(S);} paths.push(path); for(let j=1;j<stride && i+j<sp.paths;j++){ for(let t=0;t<sp.steps;t++) normalBM(rng);} }
      const bs=BS(sp.S0,sp.K,sp.r,sp.sigma,sp.T,sp.type);
      const bsLow = bs*(1-bsRiskPct), bsHigh = bs*(1+bsRiskPct);
      let tag='MC', dispMean=mean, dispSe=se, dispCIL=ciLow, dispCIH=ciHigh, ciForBarsLow=[], ciForBarsHigh=[];
      if(useCV){ const cv=controlVariate(payoffs,discST,sp.S0); tag='MC (CV)'; dispMean=cv.mean; dispSe=cv.se; dispCIL=cv.ciLow; dispCIH=cv.ciHigh; ciForBarsLow=[ciLow, cv.ciLow, bsLow]; ciForBarsHigh=[ciHigh, cv.ciHigh, bsHigh]; }
      else { ciForBarsLow=[ciLow, bsLow]; ciForBarsHigh=[ciHigh, bsHigh]; }
      const gBS=BSGreeks(sp.S0,sp.K,sp.r,sp.sigma,sp.T,sp.type); const gMC=mcPathGreeks(sp,ST,Zbar);
      const throttleNote = `Rendered paths: ${paths.length} (of ${sp.paths.toLocaleString()}); scatter capped at ~4,000 points. Antithetic=${useAntithetic?'on':'off'}. Paths log=${pathsLog?'on':'off'}. Payoff log(S)=${payoffLog?'on':'off'}.`;
      const statsEl=$('#stats'); if(statsEl){ statsEl.textContent=[ `${tag} Price: $${dispMean.toFixed(4)}`, `Std Error: ${dispSe.toFixed(4)}`, `95% CI: [${dispCIL.toFixed(4)}, ${dispCIH.toFixed(4)}]`, `Black–Scholes: $${bs.toFixed(4)} (model‑risk ±${(bsRiskPct*100).toFixed(1)}% ⇒ [${bsLow.toFixed(4)}, ${bsHigh.toFixed(4)}])`, `Settings: steps=${sp.steps}, paths=${sp.paths.toLocaleString()}, seed=${sp.seed}, type=${sp.type}`, '', 'Greeks (BS analytic):', `  Delta=${gBS.Delta.toFixed(6)}  Gamma=${gBS.Gamma.toFixed(6)}  Vega=${gBS.Vega.toFixed(6)}  Theta=${gBS['Theta (per year)'].toFixed(6)}  Rho=${gBS.Rho.toFixed(6)}`, 'Greeks (MC pathwise ±SE):', `  Delta=${gMC.delta.toFixed(6)} ± ${gMC.seDelta.toFixed(6)}`, `  Vega=${gMC.vega.toFixed(6)} ± ${gMC.seVega.toFixed(6)}`, `  Rho=${gMC.rho.toFixed(6)} ± ${gMC.seRho.toFixed(6)}`, throttleNote ].join("\n"); }
      console.log('[runSim] before charts', 'ST.len=', (ST && ST.length), 'payoffs.len=', (payoffs && payoffs.length));
      // Charts (D3)
      const histData=(function(arr,bins=30){ let vmin=Infinity,vmax=-Infinity; for(const v of arr){ if(v<vmin)vmin=v; if(v>vmax)vmax=v; } if(!Number.isFinite(vmin)||!Number.isFinite(vmax)){ vmin=0; vmax=1; } let width=vmax-vmin; if(width<=1e-12){ vmin-=0.5; vmax+=0.5; width=vmax-vmin; } const centers=new Array(bins), counts=new Array(bins).fill(0); for(const v of arr){ let idx=Math.floor(((v-vmin)/width)*bins); if(idx<0) idx=0; if(idx>=bins) idx=bins-1; counts[idx]++; } for(let i=0;i<bins;i++) centers[i]=vmin+(i+0.5)*(width/bins); return {centers,counts}; })(payoffs,30);
      drawHistogramD3('#hist', histData.centers, histData.counts);
      const labels=useCV?['MC','MC (CV)','BS']:['MC','BS'];
      const values=useCV?[mean,dispMean,bs]:[mean,bs];
      drawBarsD3('#bars', labels, values, ciForBarsLow, ciForBarsHigh);
      drawPathsD3('#pathsChart', paths, pathsLog);
      drawPayoffD3('#payoffDiagram', sp.K, sp.type, ST, payoffs, payoffLog);

      // --- Strategy recommendation ---
      try{
        // robustly locate the strategy element; prefer existing #strategy inside .strategy-card
        let stratEl = document.getElementById('strategy') || document.querySelector('.strategy-card #strategy') || (function(){ const sc = document.querySelector('.strategy-card'); return sc ? sc.querySelector('.mono') : null; })();
        // if still missing, create a strategy div inside the strategy card so UI layout remains consistent
        if(!stratEl){ const sc = document.querySelector('.strategy-card'); if(sc){ const nd = document.createElement('div'); nd.id='strategy'; nd.className='mono'; nd.style.whiteSpace='pre-wrap'; nd.style.marginTop='8px'; nd.style.color='#111'; nd.textContent=''; sc.appendChild(nd); stratEl = nd; } }
        if(stratEl){
          const meanPrice = dispMean; const sePrice = Math.max(1e-12, dispSe);
          const lower95 = dispCIL; const upper95 = dispCIH;
          // choose reference according to user toggle (auto / market / bs)
          let refName = 'BS';
          let refPrice = bs;
          if(strategySource === 'market' && Number.isFinite(marketPrice)) { refName = 'market'; refPrice = marketPrice; }
          else if(strategySource === 'auto' && Number.isFinite(marketPrice)){ refName = 'market'; refPrice = marketPrice; }
          // compute z score relative to chosen reference
          const z = (meanPrice - refPrice)/sePrice;
          // decision: use threshold provided by user
          let action = 'Hold';
          if(z > decisionZ) action = 'Buy'; else if(z < -decisionZ) action = 'Sell'; else action = 'Hold';
          // compute execution price: marketPrice if user chose market (or auto with market present), else conservative CI bound for buy/sell
          let execPrice = refPrice;
          if(refName === 'BS' && action !== 'Hold'){
            execPrice = action === 'Buy' ? lower95 : upper95;
          }
          // confidence (heuristic) using normal CDF
          let conf = 0.5;
          if(action === 'Buy') conf = cdfN(z);
          else if(action === 'Sell') conf = 1 - cdfN(z);
          else conf = Math.max(0.01, Math.min(0.99, cdfN(Math.abs(z))));
          // profit distribution (buy perspective): payoff - execPrice
          const nS = payoffs.length;
          const profits = new Array(nS);
          let psum = 0, posCount = 0;
          for(let i=0;i<nS;i++){ const v = payoffs[i] - execPrice; profits[i] = v; psum += v; if(v>0) posCount++; }
          const meanProfit = psum / Math.max(1,nS);
          const probPositive = (posCount / Math.max(1,nS));
          // percentiles
          const sorted = profits.slice().filter(Number.isFinite).sort((a,b)=>a-b);
          function quantile(arr,q){ if(arr.length===0) return NaN; const idx=(arr.length-1)*q; const lo=Math.floor(idx), hi=Math.ceil(idx); if(lo===hi) return arr[lo]; return arr[lo] + (arr[hi]-arr[lo])*(idx-lo); }
          const med = quantile(sorted,0.5), q5 = quantile(sorted,0.05), q95 = quantile(sorted,0.95);
          // draw profit histogram in 3rd column panel
          try{ const profitArr = profits; const bins=40; let vmin=Infinity,vmax=-Infinity; for(const v of profitArr){ if(v<vmin) vmin=v; if(v>vmax) vmax=v; } if(!Number.isFinite(vmin)||!Number.isFinite(vmax)){ vmin=0; vmax=1; } let width=vmax-vmin; if(width<=1e-12){ vmin-=0.5; vmax+=0.5; width=vmax-vmin; } const centers=new Array(bins), counts=new Array(bins).fill(0); for(const v of profitArr){ let idx=Math.floor(((v-vmin)/width)*bins); if(idx<0) idx=0; if(idx>=bins) idx=bins-1; counts[idx]++; } for(let i=0;i<bins;i++) centers[i]=vmin+(i+0.5)*(width/bins); try{ drawHistogramD3('#profitHist', centers, counts); }catch(e){ console.warn('[strategy] draw profit hist failed', e); } }catch(e){console.warn('[strategy] profit hist prep failed', e);}

          // format output as HTML with tooltips
          const pct = (conf*100).toFixed(1) + '%';
          function esc(v){ return String(v).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
          function row(label, value, tip){ return `<div style="margin:6px 0"><b>${esc(label)}:</b> <span title="${esc(tip||'')}">${esc(value)}</span></div>`; }
          let html = '';
          html += row('Recommendation', `${action} (${sp.type.toUpperCase()})`, 'Suggested action based on reference and z-threshold');
          html += row('Reference used', `${refName} ($${fmt(refPrice,4)})`, 'Reference price used for decision');
          html += row('MC fair price', `$${fmt(meanPrice,4)}   95% CI: [${fmt(lower95,4)}, ${fmt(upper95,4)}]`, 'Monte Carlo estimated fair price and 95% CI');
          html += row('Decision z', `${fmt(z,4)} (threshold ${fmt(decisionZ,3)})`, 'Standardised difference (MC mean - reference) / MC SE');
          html += row('Execution price (used)', `$${fmt(execPrice,4)}`, 'Price used to compute profit distribution');
          html += row('Confidence', `${pct}`, 'Heuristic confidence from MC SE (normal approx)');
          html += row('Expected profit (mean)', `$${fmt(meanProfit,4)}`, 'Mean(profit = payoff - execution price) across simulations');
          html += row('Prob(profit>0)', `${(probPositive*100).toFixed(1)}%`, 'Empirical probability profit > 0 in simulations');
          html += row('Profit percentiles (5%/50%/95%)', `$${fmt(q5,4)} / $${fmt(med,4)} / $${fmt(q95,4)}`, 'Empirical profit percentiles across simulations');
          html += '<div style="margin-top:8px; font-size:12px; color:#666">Note: distributions are over simulated discounted payoffs; results are heuristic and not financial advice.</div>';
          stratEl.innerHTML = html;

          txt.push(`\n\nRecommendation: ${action} (${sp.type.toUpperCase()})`);
          txt.push(`Reference used: ${refName} ($${fmt(refPrice,4)})`);
          txt.push(`MC fair price: $${fmt(meanPrice,4)} \n\n95% CI: [${fmt(lower95,4)}, ${fmt(upper95,4)}]`);
          txt.push(`Decision z: ${fmt(z,4)} \n\nThreshold: ${fmt(decisionZ,3)}`);
          txt.push(`Execution price (used): $${fmt(execPrice,4)}`);
          txt.push(`Confidence of favourable outcome: ${pct}`);
          txt.push(`Expected profit (mean): $${fmt(meanProfit,4)} \n\nProb(profit>0): ${(probPositive*100).toFixed(1)}%`);
          txt.push(`Profit percentiles (5/50/95):\n$${fmt(q5,4)} / $${fmt(med,4)} / $${fmt(q95,4)}\n`);
          txt.push('Note: Distributions are over simulated discounted payoffs; results are heuristic and not financial advice.');
          stratEl.textContent = txt.join('\n\n');
                  }
      }catch(e){ console.warn('[strategy] compute failed', e); }

    }
    async function runDiagnostics(){
      console.log('[runDiagnostics] invoked');
      setTimeout(async ()=>{
      console.log('[runDiagnostics] started async');
      // Hide original textarea and show diagnostics only in a <pre id="diag_out"> element.
      try{
        const t = document.getElementById('diag'); if(t){ try{ t.style.display='none'; }catch(e){} }
        let fb = document.getElementById('diag_out');
        if(!fb){ fb = document.createElement('pre'); fb.id='diag_out'; fb.style.whiteSpace='pre-wrap'; fb.style.border='1px solid #ddd'; fb.style.padding='8px'; fb.style.marginTop='8px'; fb.style.background='#fff'; const parent = document.querySelector('textarea#diag') ? document.querySelector('textarea#diag').parentNode : document.body; parent.appendChild(fb); }
        fb.textContent='(running diagnostics...)';
        console.log('[runDiagnostics] using fallback #diag_out');
      }catch(e){ console.error('[runDiagnostics] create/fill fallback failed', e); }
      const out=[]; function line(s){ out.push(s); }
      const p={ type:'call', S0:100, K:100, r:0.03, sigma:0.2, T:0.5, steps:64, paths:20000, seed:42 };
      let m1,se1,cil1,cih1,pay1;
      try{ [m1,se1,cil1,cih1,pay1] = await simulateMCAsync(p,false); } catch(e){ const r=simulateMC(p,false); [m1,se1,cil1,cih1,pay1] = r; }
      let m2,se2; try{ const r2 = await simulateMCAsync(p,true); m2 = r2[0]; se2 = r2[1]; } catch(e){ const r2=simulateMC(p,true); m2=r2[0]; se2=r2[1]; }
        const cBS=BS(p.S0,p.K,p.r,p.sigma,p.T,'call');
        const putBS=BS(p.S0,p.K,p.r,p.sigma,p.T,'put');
        const parityOK=Math.abs((cBS-putBS)-(p.S0-p.K*Math.exp(-p.r*p.T)))<1e-6;
        const repro=(await (typeof simulateMCAsync==='function' ? (async ()=>{ try{ const r=await simulateMCAsync(p,false); return r[0]; }catch(e){ return simulateMC(p,false)[0]; } })() : Promise.resolve(simulateMC(p,false)[0])));
        const reproOK=Math.abs(m1-repro)<1e-12;
        const finiteOK=[m1,se1,cil1,cih1,cBS,putBS].every(Number.isFinite)&&pay1.every(Number.isFinite);
        const hist=(function(arr,bins=30){ let vmin=Infinity,vmax=-Infinity; for(const v of arr){ if(v<vmin)vmin=v; if(v>vmax)vmax=v; } if(!Number.isFinite(vmin)||!Number.isFinite(vmax)){ vmin=0; vmax=1; } let width=vmax-vmin; if(width<=1e-12){ vmin-=0.5; vmax+=0.5; width=vmax-vmin; } const centers=new Array(bins), counts=new Array(bins).fill(0); for(const v of arr){ let idx=Math.floor(((v-vmin)/width)*bins); if(idx<0) idx=0; if(idx>=bins) idx=bins-1; counts[idx]++; } for(let i=0;i<bins;i++) centers[i]=vmin+(i+0.5)*(width/bins); return {centers,counts}; })(pay1,30);
        const histOK=hist.counts.reduce((a,b)=>a+b,0)===pay1.length;
        const callLB=Math.max(0, p.S0 - p.K*Math.exp(-p.r*p.T));
        const lbOK = m1+1e-8 >= callLB;
        const ciOK = (cil1 <= cBS && cBS <= cih1);
        const seDrop = se2 <= se1;
        // extra: odd paths handling
        const pOdd={...p, paths:20001};
        let paysOdd; try{ const rOdd = await simulateMCAsync(pOdd,true); paysOdd = rOdd[4]; } catch(e){ paysOdd = simulateMC(pOdd,true)[4]; }
        const oddOK = paysOdd.length === pOdd.paths;
        // strict printouts with 4 decimals where applicable
        line('Strict Tests:');
        line(`Put–Call Parity (BS): ${parityOK ? 'PASS' : 'FAIL'}`);
        line(`Reproducibility: ${reproOK ? 'PASS' : 'FAIL'}`);
        line(`Finite outputs: ${finiteOK ? 'PASS' : 'FAIL'}`);
        line(`Histogram counts sum: ${histOK ? 'PASS' : 'FAIL'}`);
        line(`No‑arbitrage lower bound: ${lbOK ? 'PASS' : 'FAIL'}`);
        line(`BS within 95% MC CI: ${ciOK ? 'PASS' : 'FAIL'} [${fmt(cil1,4)}, ${fmt(cih1,4)}] vs ${fmt(cBS,4)}`);
        line(`Antithetic variance reduction (SE): ${seDrop ? 'PASS' : 'FAIL'} base=${se1.toFixed(6)} anti=${se2.toFixed(6)}`);
        line(`Antithetic truncation keeps sample size: ${oddOK ? 'PASS' : 'FAIL'}`);
        // Write diagnostics only to the fallback pre#diag_out (hide textarea)
        console.log('[runDiagnostics] writing diagnostics to #diag_out only');
        const txt = out.join("\n");
        try{
          const t = document.getElementById('diag'); if(t){ try{ t.style.display='none'; }catch(e){} }
          let fb = document.getElementById('diag_out');
          if(!fb){ fb = document.createElement('pre'); fb.id='diag_out'; fb.style.whiteSpace='pre-wrap'; fb.style.border='1px solid #ddd'; fb.style.padding='8px'; fb.style.marginTop='8px'; fb.style.background='#fff'; const parent = document.querySelector('textarea#diag') ? document.querySelector('textarea#diag').parentNode : document.body; parent.appendChild(fb); }
          fb.textContent = txt;
          console.log('[runDiagnostics] wrote fallback #diag_out, len=', txt.length);
        }catch(e){ console.error('[runDiagnostics] fallback write failed', e); }
        console.log("[runDiagnostics] completed, lines=", out.length);
      }, 10);
    }
    bind('runBtn','click', runSim);
    bind('runDiag','click', runDiagnostics);
    window.addEventListener('resize', runSim);
    try { runSim(); runDiagnostics(); } catch(e){ try{ const t=document.getElementById('diag'); if(t) try{ t.style.display='none'; }catch(_){}; let fb=document.getElementById('diag_out'); if(!fb){ fb=document.createElement('pre'); fb.id='diag_out'; fb.style.whiteSpace='pre-wrap'; fb.style.border='1px solid #ddd'; fb.style.padding='8px'; fb.style.marginTop='8px'; fb.style.background='#fff'; const parent=document.querySelector('textarea#diag')?document.querySelector('textarea#diag').parentNode:document.body; parent.appendChild(fb); } fb.textContent=`[fatal] init failed: ${e}`; }catch(err){ console.error('[init] write fallback failed', err); } console.error(e); }
  });
  </script>
</body>
</html>
